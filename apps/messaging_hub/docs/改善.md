## 実装ステータス（2026-02-26）

- Step 1 設計凍結:
  - `docs/frozen-specs/01_architecture.md`
  - `docs/frozen-specs/02_tool_gateway_design.md`
  - `docs/frozen-specs/03_permission_model.md`
  - `docs/frozen-specs/04_sr_chat_api.md`
- Step 2 実装:
  - `agentflow`（署名ポリシー warn/deny、SkillResult 契約拡張、監査メタデータ強制）
  - `messaging_hub`（`/api/sr_chat/*`・`/api/approvals/*`・`/api/executions*`、SQLite 永続化、標準イベント）
  - 追加品質改善（2026-02-26）:
    - `MeetingAgent`: event_id 解決、会議履歴集計、保留アクション抽出
    - `FileOrganizerAgent`: move/rename/delete/duplicate 検出を実動化（dry_run依存の未実装を解消）
    - Admin UI: 独自 3D 感デザイン適用、Skills/Workflow 管理導線を強化
- Step 3 試験:
  - `tests/unit/test_plugin_governance_runtime.py`
  - `tests/unit/test_os_browser_skills.py`
  - `apps/messaging_hub/tests/unit/test_contract_apis.py`

---

以下は、前回の私の回答内容をそのまま日本語へ翻訳したものです（構造・意図を保持した正式な日本語表現で整理しています）。

---

# 0️⃣ 目標再整理：私たちが作るのは「チャットボット」ではなく「ローカル実行型 Agent OS」

あなたの目標を構造的に整理すると、4層構造になります：

- **入口層**：sr_chat（デフォルト）＋外部チャネル（Slack等）
- **編成層**：serverlessAIAgents / agentflow（計画・状態管理・スキル呼出・可観測性・承認）
- **実行層**：ローカル実行面（ファイル・文書・ブラウザ・アプリ自動化）＋MCP＋DB
- **統制層**：権限・監査・ロールバック・供給連鎖管理・注入防御・外部接続制限

OpenClaw が強く見える理由は「実行面」を工学的にきちんと作っているからです。
特に **管理されたブラウザ（隔離プロファイル・決定的タブ管理・スクリーンショット・PDF証跡）** は重要です。

しかし同時に、OpenClaw は「オープンなスキル市場」により重大なセキュリティ問題を起こしました。
私たちは **同じ能力を実装するが、ガバナンス下で実装する** という方針を取ります。

---

# 1️⃣ 改善点の再整理（agentflow 前提）

## 1.1 編成・実行基盤

### おそらく既に存在しているもの（再利用）

- DAG/状態機械実行エンジン
- Skill 呼出抽象
- 実行コンテキスト管理
- ストリーミング出力
- DB / Queue

### 強化が必要な部分

- 実行面との契約（ロールバック・証跡必須）
- 失敗時の部分回復戦略
- Verify ノードの強制化

### 改善提案

すべての Tool/Skill は以下を返す：

```
result
evidence
artifacts
rollback_handle
cost
risk_flags
```

---

## 1.2 権限モデル

権限は「Agent単位」ではなく：

> skill + scope + resource 範囲

### Scope例

- fs.read
- fs.write
- doc.edit
- browser.read
- browser.act
- app.control
- net.http
- db.read
- db.write
- secrets.use

### 承認種類

- 当回のみ
- 本タスク期間
- 永久許可（撤回可能）

---

## 1.3 実行面ツール

### 文書編集

- 構造化編集
- diff 生成
- ロールバック可能

### ブラウザ

- 隔離プロファイル
- 決定的タブ管理
- スクリーンショット証跡

### ローカルアプリ操作

- 第三段階で実装
- 証跡必須

---

## 1.4 記憶と自己改善

記憶は分層する：

- ユーザ記憶（編集・削除可能）
- タスク記憶（バージョン管理）
- スキル経験（テンプレート化）

自己改善は：

> 提案 → サンドボックス → テスト → 承認 → 署名 → 登録

直接本番登録は禁止。

---

# 2️⃣ 三段階ロードマップ

---

## 🟢 第1段階（MVP）

### 目標

sr_chat からローカル安全実行。

### 必須

1. sr_chat
2. Tool Gateway
3. fs.read/write（workspace限定）
4. doc.edit（最小実装）
5. net.http（ホワイトリスト）
6. 承認UI
7. Trace保存
8. リアルタイム進捗

ブラウザ操作はまだ read のみ。

---

## 🟡 第2段階

### 目標

OpenClaw級のブラウザ能力＋タスク管理

### 追加

1. 管理ブラウザ
2. Scheduler
3. Skill Registry
4. 長期記憶管理

---

## 🔴 第3段階

### 目標

完全自律・自己改善

### 追加

1. アプリ自動操作
2. 自己改善パイプライン
3. マルチAgent構成
4. 外部接続厳格制限

---

# 3️⃣ コア契約設計

---

## 3.1 Channel Adapter

統一 MessageEvent モデル。

---

## 3.2 Tool Gateway（最重要）

実行順序：

1. 入力検証
2. ポリシー評価
3. サンドボックス実行
4. 監査記録
5. イベント通知

---

## 3.3 PolicyEngine

決定結果：

- ALLOW
- DENY
- REQUIRE_APPROVAL

---

## 3.4 Skill Manifest

必須項目：

- id
- version
- entrypoint
- capabilities
- resources
- schema
- dry_run対応
- rollback対応
- tests
- signature（第二段階）

---

## 3.5 Memory API

type：

- user
- task
- skill

忘却機能必須。

---

## 3.6 Scheduler API

RunRecord構造標準化。

---

# 4️⃣ OpenClawから学ぶ点と回避策

### 学ぶ点

- 管理ブラウザ
- プラグイン化
- 複数チャネル

### 回避策

- 公開スキル市場は作らない
- 署名必須
- egress制限
- 書込は常に承認
- 自己改善は必ず審査経由
- 証跡第一主義

---

# 5️⃣ sr_chat設計

Slack風API：

- auth.test
- conversations.list
- conversations.history
- chat.postMessage
- chat.update
- files.upload
- events.subscribe

実行イベント：

- RunStarted
- StepStarted
- ToolApprovalRequested
- ToolExecuted
- EvidenceAdded
- RunFinished

未設定時は sr_chat のみ有効。

---

# 6️⃣ AIへのシステム指示テンプレート

```
あなたはローカル実行型アシスタントである。
最小リスクでタスクを完了することを目的とする。

デフォルトは読み取り専用。
書込み・外部接続・ローカル操作は承認必須。

実行前に計画を提示。
各ステップで証跡を提示。
失敗時は代替案を提示。
```

---

# 7️⃣ 将来拡張への備え

- RunRecord と Trace を第一段階から保持
- Skill Manifest を最初から導入
- Tool Gateway を唯一の出口にする

これにより第三段階でも再設計不要。

---

# 8️⃣ 必要なドキュメント作成：

- 📐 全体アーキテクチャ図（Mermaid）
- 🧩 Tool Gateway 内部設計図
- 🛡 権限モデルの詳細仕様書
- 🖥 sr_chat API 仕様書（正式版）
