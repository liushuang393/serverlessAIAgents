#!/usr/bin/env python3
"""Bootstrap test-focused environment variables into env files.

This script updates env files in-place with safe defaults for local/shared
testing. Existing non-empty values are kept unless ``--force`` is specified.
By default it updates project root `.env` and app-local `.env` files for apps
that provide `.env.example`.
"""

from __future__ import annotations

import argparse
import re
import secrets
from dataclasses import dataclass
from pathlib import Path


_ENV_LINE_RE = re.compile(r"^([A-Za-z_][A-Za-z0-9_]*)=(.*)$")
_EMPTY_SENTINELS = {"", '""', "''"}
_BOOTSTRAP_HEADER = [
    "# -----------------------------------------------------------------------------\n",
    "# AgentFlow test bootstrap (auto-generated by scripts/bootstrap_test_env.py)\n",
    "# -----------------------------------------------------------------------------\n",
]


@dataclass(slots=True)
class EnvSpec:
    """Single env variable spec."""

    key: str
    value: str


def _token(prefix: str) -> str:
    return f"{prefix}_{secrets.token_urlsafe(24)}"


def _default_specs() -> list[EnvSpec]:
    return [
        EnvSpec("LLM_PROVIDER", "mock"),
        EnvSpec("MESSAGING_HUB_API_KEY_ENV", "MESSAGING_HUB_API_KEY"),
        EnvSpec("MESSAGING_HUB_API_KEY", _token("mh")),
        EnvSpec("CODE_MIGRATION_API_KEY_ENV", "CODE_MIGRATION_API_KEY"),
        EnvSpec("CODE_MIGRATION_API_KEY", _token("cma")),
        EnvSpec("CODE_MIGRATION_CORS_ORIGINS", "http://localhost:3000,http://localhost:5173,http://localhost:5174"),
        EnvSpec("DESIGN_SKILLS_API_KEY_ENV", "DESIGN_SKILLS_API_KEY"),
        EnvSpec("DESIGN_SKILLS_API_KEY", _token("dse")),
        EnvSpec("JWT_SECRET_KEY", _token("jwt")),
        EnvSpec("FAQ_PROXY_AUTH_SHARED_SECRET", _token("faqproxy")),
        EnvSpec("POSTGRES_PASSWORD", _token("pg")),
        EnvSpec("SESSION_SECRET", _token("sess")),
    ]


def _parse_existing(lines: list[str]) -> dict[str, tuple[int, str]]:
    """Map env key -> (line index, raw value)."""
    mapping: dict[str, tuple[int, str]] = {}
    for idx, line in enumerate(lines):
        match = _ENV_LINE_RE.match(line.rstrip("\n"))
        if match is None:
            continue
        mapping[match.group(1)] = (idx, match.group(2))
    return mapping


def _should_replace(raw_value: str, force: bool) -> bool:
    if force:
        return True
    return raw_value.strip() in _EMPTY_SENTINELS


def bootstrap_env(
    env_file: Path,
    specs: list[EnvSpec],
    force: bool = False,
) -> tuple[int, int]:
    """Update env file and return (updated_count, skipped_count)."""
    lines = (
        env_file.read_text("utf-8").splitlines(keepends=True)
        if env_file.exists()
        else []
    )

    existing = _parse_existing(lines)
    updated = 0
    skipped = 0
    appended_specs: list[EnvSpec] = []

    for spec in specs:
        current = existing.get(spec.key)
        if current is None:
            appended_specs.append(spec)
            updated += 1
            continue

        idx, raw_value = current
        if _should_replace(raw_value, force):
            lines[idx] = f"{spec.key}={spec.value}\n"
            updated += 1
        else:
            skipped += 1

    if appended_specs:
        if lines and not lines[-1].endswith("\n"):
            lines[-1] = f"{lines[-1]}\n"
        if lines and lines[-1].strip():
            lines.append("\n")
        lines.extend(_BOOTSTRAP_HEADER)
        for spec in appended_specs:
            lines.append(f"{spec.key}={spec.value}\n")

    env_file.parent.mkdir(parents=True, exist_ok=True)
    env_file.write_text("".join(lines), encoding="utf-8")
    return updated, skipped


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Bootstrap test env vars into root/app env files "
            "without touching committed examples."
        ),
    )
    parser.add_argument(
        "--env-file",
        action="append",
        dest="env_files",
        default=[],
        help=(
            "Target env file path. Can be passed multiple times. "
            "Default: .env"
        ),
    )
    parser.add_argument(
        "--sync-app-env",
        action=argparse.BooleanOptionalAction,
        default=True,
        help=(
            "Also update apps/*/.env where apps/*/.env.example exists "
            "(default: true)"
        ),
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing non-empty values for managed keys",
    )
    return parser


def _iter_app_env_targets(repo_root: Path) -> list[Path]:
    """Return app-local `.env` targets for apps that expose `.env.example`."""
    return [
        example_path.with_name(".env")
        for example_path in sorted(repo_root.glob("apps/*/.env.example"))
    ]


def _dedupe_paths(paths: list[Path]) -> list[Path]:
    """Deduplicate while preserving order."""
    seen: set[Path] = set()
    result: list[Path] = []
    for path in paths:
        resolved = path.resolve()
        if resolved in seen:
            continue
        seen.add(resolved)
        result.append(resolved)
    return result


def main() -> None:
    parser = _build_parser()
    args = parser.parse_args()
    repo_root = Path.cwd()

    explicit_targets = [Path(p) for p in args.env_files] if args.env_files else [Path(".env")]
    targets: list[Path] = list(explicit_targets)
    if args.sync_app_env:
        targets.extend(_iter_app_env_targets(repo_root))
    targets = _dedupe_paths(targets)
    specs = _default_specs()

    total_updated = 0
    total_skipped = 0
    for env_file in targets:
        updated, skipped = bootstrap_env(env_file, specs=specs, force=args.force)
        total_updated += updated
        total_skipped += skipped
        print(f"[env-bootstrap] file={env_file}")
        print(f"[env-bootstrap] updated={updated} skipped={skipped}")
    print(f"[env-bootstrap] total_updated={total_updated} total_skipped={total_skipped}")
    print(f"[env-bootstrap] targets={len(targets)}")


if __name__ == "__main__":
    main()
